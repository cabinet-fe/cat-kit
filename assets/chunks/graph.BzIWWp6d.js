var t=Object.defineProperty,s=(s,e,i)=>((s,e,i)=>e in s?t(s,e,{enumerable:!0,configurable:!0,writable:!0,value:i}):s[e]=i)(s,"symbol"!=typeof e?e+"":e,i);class e{constructor(t){s(this,"config"),s(this,"rendered",!1),s(this,"graphs",[]),s(this,"ctx",null),s(this,"canvas",null),s(this,"tasksWhenMounted",[]);const{graphs:e,...i}=t;this.config=i,e&&(this.tasksWhenMounted.push((t=>{e.forEach((s=>s.bind(t)))})),this.graphs=e)}render(){const{ctx:t,config:s}=this;t&&(this.rendered&&t.clearRect(0,0,s.width,s.height),this.graphs.forEach((t=>t.draw())),this.rendered=!0)}append(t){this.ctx&&t.bind(this),this.graphs.push(t)}mount(t){const{width:s,height:e}=this.config;if("string"==typeof t){const s=document.querySelector(t);s?t=s:(console.error(`元素${t}不存在, 画布将自动挂载到body元素下`),t=document.body)}if(t instanceof HTMLCanvasElement)this.canvas=t,s&&(t.width=s),e&&(t.height=e),this.ctx=t.getContext("2d");else{const i=document.createElement("canvas");this.canvas=i,i.width=s||t.offsetWidth,i.height=e||t.offsetHeight,t.appendChild(i),this.ctx=i.getContext("2d")}for(;this.tasksWhenMounted.length;)this.tasksWhenMounted.shift()(this);this.registerEvents(),this.render()}registerEvents(){const{canvas:t}=this;t&&t.addEventListener("click",(t=>{}))}}class i{constructor(){s(this,"ctx"),s(this,"stage")}beforeDraw(){}bind(t){return this.stage?(console.warn(`${this.name}已经绑定了舞台对象，无需重复绑定`),this):(this.stage=t,this.ctx=t.ctx,this)}on(t){}}export{i as G,e as S};
