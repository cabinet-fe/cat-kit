import{_ as t,c as a,o as e,a6 as r}from"./chunks/framework.CRTY9GVS.js";const n=JSON.parse('{"title":"工作流 workflow","description":"","frontmatter":{"title":"工作流 workflow"},"headers":[],"relativePath":"shared/term/workflow.md","filePath":"shared/term/workflow.md","lastUpdated":1744265790000}'),d={name:"shared/term/workflow.md"},l=[r('<h1 id="工作流-workflow" tabindex="-1">工作流 workflow <a class="header-anchor" href="#工作流-workflow" aria-label="Permalink to &quot;工作流 workflow&quot;">​</a></h1><p>工作流是对一系列操作步骤的整合.</p><p>我们以请假来举例:</p><p><img src="/cat-kit/assets/QingJia.CAdg330d.jpg" alt="请假流程"></p><p>以上的流程中有几个重要的内容: 表单, 负责人, 审批动作. 该流程中使用了一个表单, 在发起时填写, 在审批时需要查看表单内容, 审批需要指定负责人, 审批通过和驳回都立即结束.</p><p>这里关键的一点是: 在流程发起之后流转到负责人那边需要将数据主键给到流程实例, 这样负责人才能看到填写的请假信息, 这正是工作流引擎所负责的内容.</p><h2 id="流程引擎" tabindex="-1">流程引擎 <a class="header-anchor" href="#流程引擎" aria-label="Permalink to &quot;流程引擎&quot;">​</a></h2><p>以下是常用的开源流程引擎</p><ul><li>Activiti</li><li>Flowable</li><li>Camunda</li></ul><p><a href="https://blog.csdn.net/qq_30739519/article/details/86682931" target="_blank" rel="noreferrer">这里</a>是对三个引擎的对比</p><p>相比而言国内使用 Flowable 和 Camunda 的比较多.</p><p>Camunda 的<a href="http://camunda-cn.shaochenfeng.com/" target="_blank" rel="noreferrer">中文文档</a></p><h2 id="bpmn2-0" tabindex="-1">BPMN2.0 <a class="header-anchor" href="#bpmn2-0" aria-label="Permalink to &quot;BPMN2.0&quot;">​</a></h2><p>BPMN 全称, 业务流程模型注解 Business Process Modeling Notation. 实际上就是用来描述流程各个节点和分支的一系列图形(Shape)的<strong>标准</strong>, 注意是一套标准而不是具体的实现. 一个拥有从开始到结束完整流程的图形集合被称作<strong>流程模型</strong>. 设计流程模型的过程被叫做<strong>建模</strong>. 每个模型由开始节点用户发起, 发起后立即产生一个<strong>流程实例</strong>, 流程结束之前流程实例都属于激活状态.</p><h3 id="开始事件和结束事件-start-event-and-end-event" tabindex="-1">开始事件和结束事件 Start Event and End Event <a class="header-anchor" href="#开始事件和结束事件-start-event-and-end-event" aria-label="Permalink to &quot;开始事件和结束事件 Start Event and End Event&quot;">​</a></h3><p>开始事件和结束事件分别表示流程的开始与结束, 用一个圆形表示. 通常一个流程只包含一个开始时间.</p><p>开始事件又分为三种: 空开始事件, 定时开始事件, 消息启动事件.</p><p>空开始事件顾名思义他无需任何外接触发方式来触发, 由该事件上指定的发起人发起</p><h3 id="结束事件-enn-event" tabindex="-1">结束事件 Enn Event <a class="header-anchor" href="#结束事件-enn-event" aria-label="Permalink to &quot;结束事件 Enn Event&quot;">​</a></h3><p>表示流程或分支的自然结束，什么都不做。流程所有的结束事件都到达后, 整个流程实例被标记为结束或者完成.</p><h3 id="边界事件-boundary-event" tabindex="-1">边界事件 Boundary Event <a class="header-anchor" href="#边界事件-boundary-event" aria-label="Permalink to &quot;边界事件 Boundary Event&quot;">​</a></h3><p>边界事件属于中间事件的一类。边界事件附加在活动（任务）的边界上，此时的事件只能捕获触发器。根据捕获后对路线影响的不同行为，又分为两种：边界中断事件和边界非中断事件。</p><h3 id="中间事件-intermediate-event" tabindex="-1">中间事件 Intermediate Event <a class="header-anchor" href="#中间事件-intermediate-event" aria-label="Permalink to &quot;中间事件 Intermediate Event&quot;">​</a></h3><p>在开始事件和结束事件之间发生的事件都称为中间事件。中间事件会影响流程的流转路线，但不会启动或直接终止流程的执行。</p><table tabindex="0"><thead><tr><th>中间事件</th><th>描述</th></tr></thead><tbody><tr><td>捕获时间事件</td><td></td></tr><tr><td>捕获信号事件</td><td></td></tr><tr><td>捕获消息事件</td><td></td></tr></tbody></table><h3 id="顺序流-sequence-flow" tabindex="-1">顺序流 Sequence Flow <a class="header-anchor" href="#顺序流-sequence-flow" aria-label="Permalink to &quot;顺序流 Sequence Flow&quot;">​</a></h3><p>顺序流是流程中两个元素间的连接器。在流程执行过程中，一个元素被访问后，会沿着其所有出口顺序流继续执行。 这意味着 BPMN 2.0 的默认是并行执行的, 两个出口顺序流就会创建两个独立的、并行的执行路径。 顺序流上可以添加流转条件(如果顺序流从排他网关或包容网关或复杂网关上流转出来).</p><h3 id="任务-task" tabindex="-1">任务 Task <a class="header-anchor" href="#任务-task" aria-label="Permalink to &quot;任务 Task&quot;">​</a></h3><p>任务是业务流程中的最基本单元, 一个工作流就是由各个任务组成, 任务被分为以下几种:</p><table tabindex="0"><thead><tr><th>任务</th><th>描述</th></tr></thead><tbody><tr><td>用户任务 User Task</td><td>任务的执行需要指定用户或用户组(部门,单位,角色, 职位等等)</td></tr><tr><td>服务任务 Service Task</td><td>可以用于调外部服务或自动执行程序。</td></tr><tr><td>发送任务 Send Task</td><td>发送任务是一个简单的任务，旨在向外部参与者发送消息（相对于该过程）。发送消息后，任务就完成了。</td></tr><tr><td>接收任务 Receive Task</td><td>等待外部流程参与者发送消息的任务。</td></tr><tr><td>脚本任务 Script Task</td><td>用于执行定义好的脚本程序，流程执行到这个结点自动执行脚本。</td></tr></tbody></table><h3 id="网关-gateway" tabindex="-1">网关 Gateway <a class="header-anchor" href="#网关-gateway" aria-label="Permalink to &quot;网关 Gateway&quot;">​</a></h3><p>网关用来控制顺序流的交互. 网关被分为以下几种:</p><table tabindex="0"><thead><tr><th>网关</th><th>描述</th></tr></thead><tbody><tr><td>排他网关 Exclusive Gateway</td><td>从该网关出去的流只有条件为 true 能够继续执行, 如果有多个则第一个为 true 的继续执行</td></tr><tr><td>并行网关 Parallel Gateway</td><td>并行网关用于无条件的拆分或合并分支，该类网关对连线条件是忽略的。并行网关有分支和合并两种行为，允许多进多出。</td></tr><tr><td>包容网关 Inclusive Gateway</td><td>包容网关的所有条件为 true 的后继分支都会被依次执行，如果所有分支条件决策都为 false 且该网关定义了一个默认的连线，那么该默认分支将被执行。</td></tr></tbody></table><div class="tip custom-block"><p class="custom-block-title">TIP</p><p><strong>排他拆分</strong>: 顺序判断排他网关定义的每个分支连线的条件，但最多只有一个分支被执行。使用排他网关的分支连线必须设置条件规则，未设置规则的连线被评估为 false。由于排他网关所有流出的分支按顺序评估，确定判断的顺序是非常重要的。如果后继多个分支存在都不通过的情况，应该合理的选择一个默认路径，否则引擎执行到该网关的分支将被中断于此。</p><p><strong>排他合并</strong>: 只要前置分支有一个到达，该网关的后继路径被激活。这意味着使用排他网关做合并时，应使用在一进一出的场景。如果前置可能会有多个正在执行的分支（如使用了并行网关或包容网关做路径拆分），排他网关之后的路径将在每个分支到达时被重复执行, 这就做不到排他了（除非这是你希望达成的预期结果，否则应避免这种情况的发生, 也就是说你合并的前置分支最好使用排他网关拆分的, 因为排他网关拆分的分支有且只有一条会执行）。</p></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p><strong>并行拆分</strong>: 并行网关的每个后继分支路径都被无条件执行。</p><p><strong>并行合并</strong>: 所有到达并行网关的分支路径都汇聚于此等待，直到每个输入流的分支都执行完毕，然后执行该网关的输出流，如果其中有分支未被执行或中断，那么该并行网关将处于永久等待状态。</p></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p><strong>总结</strong>: 并行网关拆分如果需要合并用并行网关合并, 可以达到会签(多个人审批通过)的效果哦. 排他网关拆分用排他网关合并.</p></div><h3 id="子流程-subprocess" tabindex="-1">子流程 Subprocess <a class="header-anchor" href="#子流程-subprocess" aria-label="Permalink to &quot;子流程 Subprocess&quot;">​</a></h3><h3 id="监听器-listener" tabindex="-1">监听器 Listener <a class="header-anchor" href="#监听器-listener" aria-label="Permalink to &quot;监听器 Listener&quot;">​</a></h3><h2 id="审批动作名词解释" tabindex="-1">审批动作名词解释 <a class="header-anchor" href="#审批动作名词解释" aria-label="Permalink to &quot;审批动作名词解释&quot;">​</a></h2><ul><li>会签, 多个节点同时完成</li><li>加签, 流程实例上单独加一个或多个节点</li><li>补签, 补充说明</li><li>通知, 某个节点流入或流出时, 可由监听器发起</li><li>催办, 流程发起者可以催办来给当前处理人发起催办</li><li>撤回, 执行完成后立即撤回</li></ul><h2 id="对请假流程的拓展" tabindex="-1">对请假流程的拓展 <a class="header-anchor" href="#对请假流程的拓展" aria-label="Permalink to &quot;对请假流程的拓展&quot;">​</a></h2><p>基于文章首页的基础请假流程, 可以拓展出更多的流程模型.</p>',42)];const o=t(d,[["render",function(t,r,n,d,o,i){return e(),a("div",null,l)}]]);export{n as __pageData,o as default};
